<!DOCTYPE HTML>
<html>
<head>
  <title>Timeline | Basic demo</title>

  <style type="text/css">
    body, html {
      font-family: sans-serif;
    }
    .vis-item.vis-box.default, .legend span.default {
      border: thick solid lightgray;
    }
    .vis-item.vis-box.supporting, .legend span.supporting {
      background-color: red;
      color: white;
      border: thick solid red;
    }
    .vis-item.vis-box.proposalEndorsement, .legend span.proposalEndorsement {
      background-color: blue;
      color: white;
      border: thick solid blue;
    }
    .vis-item.vis-box.endorsesProposal, .legend span.endorsesProposal {
      background-color: green;
      color: white;
      border: thick solid green;
    }
    .vis-item.vis-box.proposal, .legend span.proposal {
      background-color: lime;
      color: black;
      border: thick solid lime;
    }
    .vis-item.vis-box.treeParent, .legend span.treeParent {
      background-color: tan;
      color: black;
      border: thick solid tan;
    }
    .vis-item.vis-box.parent, .legend span.parent {
      border: thick solid black;
    }
    .vis-item.vis-box.parentplus, .legend span.parentplus {
      border: thick solid gray;
    }
    .vis-item.vis-box.child, .legend span.child {
      border: thick solid darkmagenta;
    }
    .vis-item.vis-box.childplus, .legend span.childplus {
      border: thick solid magenta;
    }
    .legend {
      padding: 0.25em;
    }
    .legend > span {
      border: 1px solid black;
      padding: 0.25em;
    }
  </style>

  <script
    src="https://code.jquery.com/jquery-3.2.1.min.js"
    integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
    crossorigin="anonymous"></script>
  <!--<script src="../../dist/vis.js"></script>-->
  <script src="https://unpkg.com/vis-timeline@6.2.7/dist/vis-timeline-graph2d.min.js"></script>
  <!-- https://github.com/javdome/timeline-arrows -->
  <script src="arrow.js"></script>
  <script src="data/lh-tl--index.js"></script>
  <link href="https://unpkg.com/vis-timeline@6.2.7/dist/vis-timeline-graph2d.min.css" rel="stylesheet" type="text/css" />
</head>
<body>

<div>
<label for="inputs">Input</label>
<select name="inputs" id="inputs">
</select>
<br>
<label for="dataurl">URL</label>
<input id="dataurl"></input>
<input id="dataload" type="submit" value="Load">
</div>
<hr>
<div class="menu">
  View:
  <input type="button" id="zoomAll" value="[ ]" />
  <input type="button" id="zoomIn" value="+" />
  <input type="button" id="zoomOut" value="-" />
  <input type="button" id="moveLeft" value="<<" />
  <input type="button" id="moveRight" value=">>" />
</div>
<hr>
<div class="legend">
  Legend:
  <span class="default">default</span>
  <span class="supporting">supporting</span>
  <span class="proposalEndorsement">proposal endorsement</span>
  <span class="endorsesProposal">endorses proposal</span>
  <span class="proposal">proposal</span>
  <!--<span class="treeParent">tree parent</span>-->
  <span class="parent">parent</span>
  <span class="parentplus">parent+</span>
  <span class="child">child</span>
  <span class="childplus">child+</span>
</div>
<hr>

<div id="title"></div>
<div id="visualization"></div>
<div id="loading" hidden>Loading...</div>
<div id="errors"></div>
<pre id="selected"></pre>

<script type="text/javascript">

const epoch = new Date(0);
const tScale = 10;
// map to larger "time" so can zoom out
function t(n) {
  return new Date(n * tScale);
}

let timeline;
let arrow;

function clearTimeline() {
  $('#loading').hide();
  $('#title').empty();
  $('#visualization').empty();
  $('#errors').empty();
  $('#selected').empty();
  delete timeline;
  delete arrow;
}

function setupTimeline(data) {
  console.log('DATA', data);
  // DOM element where the Timeline will be attached
  const container = document.getElementById('visualization');

  if(data.display && data.display.title) {
    $('#title').html(data.display.title);
  }

  /*
  const groups = new vis.DataSet([
    {id: 1, order: 1, content: 'Alpha'},
    {id: 2, order: 2, content: 'Beta'},
    {id: 3, order: 3, content: 'Delta'},
    {id: 4, order: 4, content: 'Gamma'},
    {id: 5, order: 5, content: 'Epsilon'},
  ]);
  */
  const groups = new vis.DataSet();
  for(const e of data.nodes) {
    if(!groups.get(e.creatorName)) {
      const options = {
        id: e.creatorName,
        content: e.creatorName,
        order: Infinity
      };
      if(data.display && data.display.nodeOrder) {
        const idx = data.display.nodeOrder.indexOf(e.creatorName);
        if(idx !== -1) {
          options.order = idx;
        }
      }
      groups.add(options);
    }
  }

  // Create a DataSet (allows two way data-binding)
  /*
  const items = new vis.DataSet([
    {id: 1, content: 'item 1', group: 1, start: t(0)},
    {id: 2, content: 'item 2', group: 2, start: t(1)},
    {id: 3, content: 'item 3', group: 3, start: t(2)},
    {id: 4, content: 'item 4', group: 4, start: t(3)},
    {id: 5, content: 'item 5', group: 4, start: t(3)},
    {id: 6, content: 'item 6', group: 5, start: t(4)},
  ]);
  */
  // topological order
  let maxTimeIndex = 0;
  // create structure
  const sortIn = {};
  data.nodes.forEach(e => {
    sortIn[e.id] = e.parents;
  });
  sortOut = topologicalSort(sortIn);
  sortOut.reverse();
  const timeIndexes = {};
  // one per index
  /*
  sortOut.forEach((id, i) => {
    timeIndexes[id] = i;
  });
  maxTimeIndex = sortOut.length;
  */
  // compact
  const idMap = {};
  data.nodes.forEach(e => idMap[e.id] = e);
  for(const id of sortOut) {
    const e = idMap[id];
    let index;
    if(e.parents.length) {
      // index is max parent index + 1
      const parentIndexes = e.parents.map(p => timeIndexes[p]);
      index = Math.max(...parentIndexes) + 1;
    } else {
      index = 0;
    }
    timeIndexes[id] = index;
    maxTimeIndex = Math.max(maxTimeIndex, index);
  }
  //console.log('M', maxTimeIndex);
  //console.log('TI', timeIndexes);
  //console.log('TS', data.nodes.map(e => timeIndexes[e.id]));

  const items = new vis.DataSet(data.nodes.map((e, i) => ({
    id: e.id,
    className: 'default',
    content: e.name || `[${e.creatorName}]`,
    group: e.creatorName,
    //start: t(i)
    start: t(timeIndexes[e.id])
  })));

  /*
  const arrows_array = [
    {id: 1, id_item_1: 1, id_item_2: 2},
    {id: 2, id_item_1: 2, id_item_2: 3},
    {id: 3, id_item_1: 3, id_item_2: 4},
    {id: 3, id_item_1: 3, id_item_2: 5},
    {id: 4, id_item_1: 2, id_item_2: 6},
  ];
  */
  const arrows_array = [];
  for(const node of data.nodes) {
    for(const parent of node.parents) {
      arrows_array.push({
        id: arrows_array.length,
        id_item_1: parent,
        id_item_2: node.id
      });
    }
  }

  // Configuration for the Timeline
  const options = {
    format: {
      minorLabels: (date, scale, step) => {
        const d = (date - epoch) / tScale;
        if(d % 1 !== 0) {
          return '';
        }
        return d;
      },
      majorLabels: (date, scale, step) => {
        return '';
      }
    },
    start: t(0),
    end: t(maxTimeIndex),
  };

  // Create a Timeline
  timeline = new vis.Timeline(container, items, groups, options);
  // Create arrows
  arrow = new Arrow(timeline, arrows_array);

  // selection
  timeline.on('select', ({items, event}) => {
    if(items.length === 0) {
      $('#selected').text('');
    } else {
      const e = idMap[items[0]];
      $('#selected').text(JSON.stringify(e, null, 2));
    }
  });

  function _parents(id) {
    return idMap[id].parents;
  }

  function __parents(id, parents) {
    _parents(id).forEach(p => {
      parents.add(p);
      __parents(p, parents);
    });
  }

  // parents parents, etc
  function _parentsplus(id) {
    const parentsplus = new Set();
    __parents(id, parentsplus);
    // remove direct parents
    _parents(id).forEach(p => parentsplus.delete(p));
    return [...parentsplus];
  }

  function _children(id) {
    return data.nodes
      .filter(node => node.parents.includes(id))
      .map(node => node.id);
  }

  function __children(id, children) {
    _children(id).forEach(c => {
      children.add(c);
      __children(c, children);
    });
  }

  // childrens children, etc
  function _childrenplus(id) {
    const childrenplus = new Set();
    __children(id, childrenplus);
    // remove direct children
    _children(id).forEach(c => childrenplus.delete(c));
    return [...childrenplus];
  }

  // hover
  timeline.on('itemover', ({item, event}) => {
    //console.log('OVER', item);
    const e = idMap[item];
    for(const id of e.supporting) {
      items.update({id, className: 'supporting'});
    }
    for(const id of e.proposalEndorsement) {
      items.update({id, className: 'proposalEndorsement'});
    }
    for(const id of e.endorsesProposal) {
      items.update({id, className: 'endorsesProposal'});
    }
    for(const id of e.proposal) {
      items.update({id, className: 'proposal'});
    }
    //for(const id of e.treeParent) {
    //  items.update({id, className: 'treeParent'});
    //}

    // below are done last to add to above classes
    for(const id of _parents(item)) {
      const _class = items.get(id).className;
      items.update({id, className: `${_class} parent`});
    }
    for(const id of _parentsplus(item)) {
      const _class = items.get(id).className;
      items.update({id, className: `${_class} parentplus`});
    }
    for(const id of _children(item)) {
      const _class = items.get(id).className;
      items.update({id, className: `${_class} child`});
    }
    for(const id of _childrenplus(item)) {
      const _class = items.get(id).className;
      items.update({id, className: `${_class} childplus`});
    }
  });
  timeline.on('itemout', ({item, event}) => {
    //console.log('OUT', item);
    const e = idMap[item];
    for(const id of e.supporting) {
      items.update({id, className: 'default'});
    }
    for(const id of e.proposalEndorsement) {
      items.update({id, className: 'default'});
    }
    for(const id of e.endorsesProposal) {
      items.update({id, className: 'default'});
    }
    for(const id of e.proposal) {
      items.update({id, className: 'default'});
    }
    //for(const id of e.treeParent) {
    //  items.update({id, className: 'default'});
    //}
    for(const id of _parents(item)) {
      items.update({id, className: 'default'});
    }
    for(const id of _parentsplus(item)) {
      items.update({id, className: 'default'});
    }
    for(const id of _children(item)) {
      items.update({id, className: 'default'});
    }
    for(const id of _childrenplus(item)) {
      items.update({id, className: 'default'});
    }
  });
}

function load(dataUrl) {
  clearTimeline();
  $('#loading').show();
  // load data via an ajax request. When the data is in, load the timeline
  $.ajax({
    url: dataUrl,
    cache: false,
    success: function(data) {
      // hide the "loading..." message
      $('#loading').hide();
      setupTimeline(data);
    },
    error: function(err) {
      console.log("Error", err);
      //$('#errors').text('x' + err.toString());
      const e = {status: err.status, message: err.statusText};
      $('#errors').text('Error: ' + JSON.stringify(e, null, 2));
    }
  });
}

function main() {
  clearTimeline();
  const info = [
    //'./example-1.json',
    ...window._indexForTimeline
  ];
  for(const item of info) {
    $('<option/>').val(item.url).html(item.label).appendTo('#inputs');
  }

  $('#inputs').change(function(e) {
    const url = e.target.value;
    console.log('loading', {url});
    $('#dataurl').val(url);
    load(url);
  });

  $('#dataurl').val($('#inputs').val());
  $('#dataload').click(function() {
    load($('#dataurl')[0].value);
  });

  $('#zoomAll').on('click', function() {
    timeline.fit();
  });
  $('#zoomIn').on('click', function() {
    timeline.zoomIn(0.2);
  });
  $('#zoomOut').on('click', function() {
    timeline.zoomOut(0.2);
  });
  $('#moveLeft').on('click', function() {
    move(0.2);
  });
  $('#moveRight').on('click', function() {
    move(-0.2);
  });

  /**
   * Move the timeline a given percentage to left or right
   * @param {Number} percentage   For example 0.1 (left) or -0.1 (right)
   */
  function move (percentage) {
    const range = timeline.getWindow();
    const interval = range.end - range.start;

    timeline.setWindow({
      start: range.start.valueOf() - interval * percentage,
      end: range.end.valueOf() - interval * percentage
    });
  }
}

// https://mgechev.github.io/javascript-algorithms/graphs_others_topological-sort.js.html
var topologicalSort = (function () {
  function topologicalSortHelper(node, visited, temp, graph, result) {
    temp[node] = true;
    var neighbors = graph[node];
    for (var i = 0; i < neighbors.length; i += 1) {
      var n = neighbors[i];
      if (temp[n]) {
        throw new Error('The graph is not a DAG');
      }
      if (!visited[n]) {
        topologicalSortHelper(n, visited, temp, graph, result);
      }
    }
    temp[node] = false;
    visited[node] = true;
    result.push(node);
  }
  /**
   * Topological sort algorithm of a directed acyclic graph.
   * Time complexity: O(|E| + |V|) where E is a number of edges
   * and |V| is the number of nodes.
   *
   * @public
   * @module graphs/others/topological-sort
   * @param {Array} graph Adjacency list, which represents the graph.
   * @returns {Array} Ordered vertices.
   *
   * @example
   * var graph = {
   *     v1: ['v2', 'v5'],
   *     v2: [],
   *     v3: ['v1', 'v2', 'v4', 'v5'],
   *     v4: [],
   *     v5: []
   * };
   * var vertices = topologicalSort(graph); // ['v3', 'v4', 'v1', 'v5', 'v2']
   */
  return function (graph) {
    var result = [];
    var visited = [];
    var temp = [];
    for (var node in graph) {
      if (!visited[node] && !temp[node]) {
        topologicalSortHelper(node, visited, temp, graph, result);
      }
    }
    return result.reverse();
  };
}());

$(document).ready(function() {
  main();
});

</script>
</body>
</html>
